%!TEX program = xelatex
\documentclass[12pt,a4paper]{article}
\usepackage{polyglossia}
\setmainlanguage[variant=mono]{greek}
\setotherlanguage{english}
\setmainfont[Mapping=tex-text]{GFS Elpis}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{tikz-qtree} % To draw the trees
\usepackage{tikz-qtree-compat}
\author{Γραμμένος Θεόδωρος, Μπούας Χρήστος}
\title{Δομές Δεδομένων}
\date{Α.Ε.Μ.: 3294 - 3315}
\begin{document}
    \maketitle
    \tableofcontents
    \section*{Εισαγωγή}
    Στο κειμενό αυτό περιγράφεται η υλοποίηση της εργασίας μας στο μάθημα των δομών δεδομένων,
    η οποία αφορούσε την υλοποίηση κάποιων δομών σε C++. Αρχικά, αναλύονται οι δομές και οι μέθοδοί τους (ο
    τρόπος λειτουργίας τους και ο σκοπός τους). Έπειτα περιγράφεται ο τρόπος λειτουργίας της συνάρτησης main.
    \part*{Υλοποίηση δομών}
    Συνολικά υλοποιήθηκαν 7 δομές, οι 5 που περιέχονταν στην εργασία και 2 βοηθητικές(στοίβα και λίστα). Όλες οι
    δομές υπάγονται σε μία superclass \textbf{DataStructure} η οποία περιέχει 2 virtual μεθόδους τις οποίες
    υιοθετούν όλες οι δομές: insert και getSize.
    \section{Δέντρο AVL}
    Για το δέντρο AVL δημιουργήθηκε ένα struct \textbf{AVLNode} το οποίο παριστάνει έναν κόμβο του δένδρου και αποτελείται από:
        \begin{itemize}
            \item Δύο pointers στο αριστερό και δεξί παιδί του κόμβου.
            \item Μία μεταβλητή height με το ύψος του υποδένδρου που ορίζεται από αυτόν τον κόμβο.
            \item Μία μεταβλητή value με το περιεχόμενο του κόμβου.
        \end{itemize}
    \begin{table}[h!]
        \centering
        \begin{tabular}{|l|l|}
        \hline
        numOfElements & Ο αριθμός των στοιχείων στο δένδρο \\ \hline
        root          & Δείκτης στη ρίζα του δένδρου       \\ \hline
        \end{tabular}
        \caption{Μεταβλητές της κλάσης}
    \end{table}
    Ο παράγοντας ισορροπίας($bf$) ενός κόμβου είναι:\\ $bf = \text{ύψος αριστερού υποδένδρου} - \text{ύψος δεξιού υποδένδρου}$ 
    \subsection*{Μέθοδοι}
    \subsection{newnode}\label{newnode}
    Η συνάρτηση \textbf{newnode} δημιουργεί ένα νέο κόμβο και του αρχικοποιεί τις τιμές του.
    \subsection{search}
    Η συνάρτηση \textbf{search} εντοπίζει εάν ένα στοιχείο υπάρχει στο δένδρο και επιστρέφει true ή false.
    \subsection{getHeight \& getBalanceFactor}
    Οι βοηθητικές αυτές συναρτήσεις υπολογίζουν: το ύψος του υποδένδρου που έχει ρίζα τον κόμβο που δίνεται ως όρισμα και τον παράγοντα ισορροπίας του 
    δοσμένου κόμβου. Χρησιμοποιούμε τις συναρτήσεις αυτές γιατί σε κάποιες περιπτώσεις χρειάζεται να υπολογίσουμε αυτές τις τιμές για την τιμή NULL και 
    δεν μπορούμε να εξετάσουμε απευθείας την τιμή \textbf{height} ενός κόμβου.
    \subsection{recursiveInsert}
    Η συνάρτηση αυτή εισάγει αναδρομικά ένα στοιχείο στο δένδρο AVL.\\ Πρώτα ελέγχεται εάν δοθεί ως όρισμα NULL pointer. Τότε, βρισκόμαστε 
    στη σωστή θέση του δένδρου και απλώς δημιουγείται ένας νέος κόμβος μέσω της newnode. Έπειτα εξετάζεται εάν χρειάζεται να μετακινηθούμε πιο κάτω στο δένδρο. 
    Σε αυτή την περίπτωση ξανακαλείται η συνάρτηση με όρισμα το δεξί ή το αριστερό παιδί του κόμβου που βρισκόμαστε και αναθέτουμε τον κόμβο που επιστρέφει στο 
    αντίστοιχο παιδί. Αφού τοποθετηθεί το στοιχείο στη σωστή θέση, αρχίζει να ``μαζεύεται'' η αναδρομή. Για κάθε κόμβο στη διαδρομή έως το στοιχείο ενημερώνουμε  
    το ύψος του και βρίσκουμε τον παράγοντα ισορροπίας του. Στη συνέχεια εξετάζεται εάν υπάρχει ανισορροπία στον κόμβο και εκτελούνται οι απαραίτητες περιστροφές:
    \begin{itemize}
        \item Αν ο παράγοντας ισορροπίας του κόμβου είναι > 1 και το στοιχείο τοποθετήθηκε στα αριστερά του αριστερού παιδιού εκτελείται μια απλή δεξιά περιστροφή.
            \begin{figure}[h!]
                \centering
                \tikzset{every tree node/.style={minimum width=2em,draw,circle},
                blank/.style={draw=none},
                edge from parent/.style=
                {draw,edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}},
                level distance=1.5cm}
                \begin{tikzpicture}
                \Tree [.z [.x [.y T4 T3 ] T2 ] T1 ]
                \end{tikzpicture}
                \begin{tikzpicture}
                \Tree [.x [.y T4 T3 ] [.z T2 T1 ] ]
                \end{tikzpicture}
                \caption{Δεξιά περιστροφή}
                \label{right}
            \end{figure}
        \item Αν ο παράγοντας ισορροπίας του κόμβου είναι -1< και το στοιχείο τοποθετήθηκε στα δεξιά του δεξιού παιδιού εκτελείται μια απλή αριστερή περιστροφή.
            \begin{figure}[h!]
                \centering
                \tikzset{every tree node/.style={minimum width=2em,draw,circle},
                blank/.style={draw=none},
                edge from parent/.style=
                {draw,edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}},
                level distance=1.5cm}
                \begin{tikzpicture}
                \Tree [.z Τ1 [.x T2 [.y T3 T4 ] ] ]
                \end{tikzpicture}
                \begin{tikzpicture}
                \Tree [.x [.y T4 T3 ] [.z T2 T1 ] ]
                \end{tikzpicture}
                \caption{Αριστερή περιστροφή}
                \label{left}
            \end{figure}
        \item Αν ο παράγοντας ισορροπίας του κόμβου είναι > 1 και το στοιχείο τοποθετήθηκε στα δεξιά του αριστερού παιδιού εκτελείται μια αριστερή περιστροφή 
        στο αριστερό παιδί και μία δεξιά περιστροφή στον κόμβο.
        \begin{figure}[h!]
            \centering
            \tikzset{every tree node/.style={minimum width=2em,draw,circle},
            blank/.style={draw=none},
            edge from parent/.style=
            {draw,edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}},
            level distance=1.5cm}
            \begin{tikzpicture}
            \Tree [.z [.x T4 [.y T3 T2 ] ] T1 ]
            \end{tikzpicture}
            \begin{tikzpicture}
            \Tree [.z [.y [.x T4 T3 ] T2 ] T1 ]
            \end{tikzpicture}
            \begin{tikzpicture}
            \Tree [.y [.x T4 T3 ] [.z T2 T1 ] ]
            \end{tikzpicture}
            \caption{Αριστερή-δεξιά περιστροφή}
        \end{figure}
        \item Αν ο παράγοντας ισορροπίας του κόμβου είναι -1< και το στοιχείο τοποθετήθηκε στα αριστερά του δεξιού παιδιού εκτελείται μια δεξιά περιστροφή 
        στο δεξί παιδί και μια αριστερή περιστροφή στον κόμβο.
        \begin{figure}
            \centering
            \tikzset{every tree node/.style={minimum width=2em,draw,circle},
            blank/.style={draw=none},
            edge from parent/.style=
            {draw,edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}},
            level distance=1.5cm}
            \begin{tikzpicture}
            \Tree [.z T1 [.x [.y T2 T3 ] T4 ] ]
            \end{tikzpicture}
            \begin{tikzpicture}
            \Tree [.z T1 [.y T2 [.x T3 T4 ] ] ]
            \end{tikzpicture}
            \begin{tikzpicture}
            \Tree [.y [.z T1 T2 ] [.x T3 T4 ] ]
            \end{tikzpicture}
            \caption{Αριστερή-δεξιά περιστροφή}
        \end{figure}
    \end{itemize}
    \newpage
    Σε κάθε περίπτωση επιστρέφεται η νέα ρίζα του υποδένδρου για να τοποθετηθεί στη σωστή θέση από τo επόμενο instance της συνάρτησης που θα εκτελεστεί.
    \subsection{insert}
    Η συνάρτηση \textbf{insert} καλεί την \textbf{recursiveInsert} δίνοντάς της ως όρισμα το στοιχείο που θα εισαχθεί και έναν δείκτη στη ρίζα του δέντρου.
    \subsection{leftrotate \& rightrotate}
    Οι συναρτήσεις \textbf{rightrotate} και \textbf{leftrotate} υλοποιούν την δεξιά και αριστερή περιστροφή, όπως φαίνονται στα σχήματα 1 και 2 
    αντίστοιχα.
    \subsection{remove}
    Η συνάρτηση \textbf{remove} αφαιρεί ένα στοιχείο από το δένδρο. Σε αυτή τη συνάρτηση χρησιμοποιείται η στοίβα που υλοποιήθηκε προκειμένου να αποθηκευτούν οι 
    κόμβοι που διασχίζονται μέχρι να βρεθεί το στοιχείο(το μονοπάτι έως το στοιχείο). Αφού εντοπιστεί το στοιχείο διακρίνονται 3 περιπτώσεις, ανάλογα με τον 
    αριθμό των παιδιών του κόμβου που  περιέχει το στοιχείο:
    \begin{itemize}
        \item Εάν ο κόμβος δεν έχει παιδιά τότε απλώς διαγράφεται ο κόμβος και ενημερώνεται ο γονέας του
        \item Εάν ο κόμβος έχει 1 παιδί τότε το παιδί τοποθετείται στη θέση του κόμβου
        \item Εάν ο κόμβος έχει 2 παιδιά τότε τοποθετούμε στη θέση του διαγραμμένου στοιχείου, το μεγαλύτερο στοιχείο του αριστερού υποδένδρου. Σε αυτήν την 
        περίπτωση χρησιμοποιείται η συνάρτηση\\ \textbf{deleteLargestSubtreeElement}.
    \end{itemize}
    Στη συνέχεια ελέγχονται όλα τα στοιχεία στη στοίβα για τυχόν ανισορροπίες που προέκυψαν. Εάν εντοπιστούν, πραγματοποιούνται οι απαραίτητες περιστροφές.
    \subsection{deleteLargestSubtreeElement}
    Η συνάρτηση δέχεται ως όρισμα έναν κόμβο και τον γονέα του. Εντοπίζει το μεγαλύτερο στοιχείο στο υποδένδρο που ορίζεται από αυτόν τον κόμβο, το διαγράφει και 
    επιστρέφει την τιμή του.
    \subsection{findmin}
    Επιστρέφει το ελάχιστο στοιχείο στο δέντρο, το οποίο βρίσκεται κάτω αριστερά σε αυτό.
    \section{Maxheap \& Minheap}
    Οι υλοποιήσεις διαφέρουν στο ότι στο maxheap χρησιμοποιείται το vector ενώ στο minheap γίνεται δυναμική διαχείριση ``με το χέρι".
    \subsection*{Μέθοδοι}
    \subsection{insert}
    Η μέθοδος insert εισάγει ένα νέο στοιχείο στο σωρό. Το στοιχείο αρχικά εισάγεται στο τέλος του πίνακα/vector και ``ανεβαίνει" στο δένδρο όσο είναι μικρότερο/
    μεγαλύτερο από το γονέα του, ώστε να τοποθετηθεί στη σωστή θέση.
    \subsection{removeMin/removeMax}
    Οι μέθοδοι αυτοί αφαιρούν το ελάχιστο/μέγιστο στοιχείο από το δένδρο. Για να γίνει αυτό, αρχικά μετακινείται το τελευταίο στοιχείο του πίνακα στη ρίζα και στη 
    συνέχεια το στοιχείο ``κατεβαίνει'' στο δέντρο με συνεχείς αντιμεταθέσεις, φέρνοντας το μέγιστο/ελάχιστο στη ρίζα και διατηρώντας τις ιδιότητες του σωρού.
    \section{Hashtable}
    Η υλοποίηση του έγινε με διπλό κατακερματισμό.
    \subsection*{Μεταβλητές}
    Η κλάση που υλοποιεί τη δομή περιέχει τις μεταβλητές:
    \begin{itemize}
        \item Τον πίνακα, table, στον οποίο αποθηκεύονται τα στοιχεία. Ο πίνακας δεσμεύεται δυναμικά.
        \item Έναν πίνακα bool, hash\_keys, στον οποίο δηλώνονται οι κατειλημμένες θέσεις του παραπάνω πίνακα. Το μέγεθος του πίνακα ορίζεται δυναμικά.
        \item Μία μεταβλητή που αποθηκεύει το μέγεθος του πίνακα, size.
        \item Μία μεταβλητή που μετράει τον αριθμό των στοιχείων στον πίνακα, numOfElements.
        \item Μία μεταβλητή τύπου float που αποθηκεύει το τρέχον ποσοστό στοιχείων στον πίνακα, spaceUsed. Η spaceUsed ορίζεται ως:\\ numOfElements/size.
    \end{itemize}
    \subsection*{Μέθοδοι}
    Η δομή υποστηρίζει τις εξής μεθόδους:
    \begin{itemize}
        \item Έναν κενό κατασκευαστή, ο οποίος:  δεσμεύει χώρο  για  τους δύο πίνακες (8 θέσεις στον καθένα), 
        ενημερώνει το size, αρχικοποιεί όλες τις θέσεις του hash\_keys σε false, ορίζει τα numOfElements και spaceUsed σε 0. 
        \item Εναν getter: \textbf{getsize} που επιστρέφει τον αριθμό των στοιχείων που υπάρχουν στον πίνακα.
        \item Δύο Hash συναρτήσεις, για τον διπλό κατακερματισμό. Οι συναρτήσεις παίρνουν ως όρισμα μία τιμή, και επιστρέφουν το Hash Key της.
        \item Μία συνάρτηση που υλοποιεί διπλό κατακερματισμό, doubleHashing(value, i). Όπου i ο πολλαπλασιαστής της δεύτερης Hash συνάρτησης.
        \item Μία συνάρτηση που διπλασιάζει το μέγεθος του πίνακα, Hash\_Table\_X2(). Η συνάρτηση: 1) δημιουργεί προσωρινό πίνακα-αντίγραφο του table, 
        2) δεσμεύει διπλάσιο χώρο για τους πίνακες table και hash\_keys, 3) αντιγράφει τα στοιχεία πίσω στον αρχικό πίνακα table, 
        χρησιμοποιώντας διπλό κατακερματισμό.
        \item Μία συνάρτηση αναζήτησης της θέσης ζητούμενου στοιχείου,\\getElementPos(value), η οποία αναζητά με την αντίστροφη διαδικασία από αυτή του 
        διπλού κατακερματισμού, τη θέση του value, στον πίνακα. 
        \item Συνάρτηση insert, η οποία εισάγει ένα στοιχείο στον πίνακα. Αρχικά ελέγχει αν ο χώρος που καταλαμβάνεται, spaceUsed, είναι μεγαλύτερος του 50\%. 
        Αν είναι, τον διπλασιάζει μέσω της Hash\_Table\_X2(). Αν δεν είναι, πραγματοποιεί εισαγωγή, χρησιμοποιώντας την doubleHashing(). 
        \item Συνάρτηση search, η οποία αναζητά ένα στοιχείο στον πίνακα, και επιστρέφει μια bool τιμή ανάλογα.  Πραγματοποιεί την αντίστροφη διαδικασία από αυτή του διπλού κατακερματισμού. 
    \end{itemize}
    \section{Γράφημα}
    Η υλοποίησή του έγινε με λίστες γειτονικότητας.
    \paragraph*{}
    Αρχικά, δημιουργήθηκε ένα struct Vertex, που αναπαριστά τον κόμβο του γραφήματος. 
    Στο struct υπάρχουν: α) ένας δείκτης σε λίστα (η λίστα με τους γείτονες του κόμβου), και β) το id του κόμβου (ακέραιος αριθμός). 
    \subsection*{Μεταβλητές}
    Το γράφημα περιλαμβάνει τις εξής μεταβλητές: 
    \begin{itemize}
        \item Έναν πίνακα, κάθε θέση του οποίου είναι δείκτης σε Vertex. Το μέγεθος του πίνακα δεσμεύεται δυναμικά.
        \item Δύο μεταβλητές, vertices και edges, οι οποίες αποθηκεύουν τον αριθμό κόμβων και ακμών αντίστοιχα. 
        \item Μία μεταβλητή, capacity, που αποθηκεύει το μέγεθος του πίνακα.
        \item Πίνακες S και distance, βοηθητικοί για την Dijkstra(). 
        Ο S αποθηκεύει ποιες κορυφές έχουμε ελέγξει, ενώ ο distance αποθηκεύει το μικρότερο κόστος για να φτάσουμε από την αρχική κορυφή σε όλες τις άλλες. 
    \end{itemize}
    \subsection*{Μέθοδοι}
    \begin{itemize}
        \item Έναν κενό κατασκευαστή.
        \item Getters για τον αριθμό των κόμβων και των ακμών.
        \item Μία συνάρτηση, findpos(id), που παίρνει ως όρισμα ένα id κόμβου και επιστρέφει τη θέση του κόμβου στον πίνακα (εάν υπάρχει).
        \item Μία συνάρτηση, deg(id), που επιστρέφει τον βαθμό της κορυφής. 
        Χρησιμοποιεί την findpos για να βρει τη θέση της κορυφής στον πίνακα και έπειτα απαριθμεί τους κόμβους της λίστας που εκτείνεται από τη συγκεκριμένη θέση του πίνακα.
        \item Δύο συναρτήσεις, vertexExists(id) και edgeExists(v1,v2), που επιστρέφουν αν υπάρχει αυτή κορυφή ή, αντίστοιχα, η ακμή.
        \item Μία συνάρτηση, insertVertex(id), που εισάγει κόμβο με το συγκεκριμένο id. Ελέγχει αν υπάρχει αρκετός χώρος στον πίνακα. Έπειτα δημιουργεί νέο Vertex.
        \item Μία συνάρτηση, insertEdge(v1,v2), που εισάγει ακμή ανάμεσα σε δύο κόμβους. Ελέγχει αν υπάρχουν και οι δύο κόμβοι. Αν δεν υπάρχει κάποιος από τους δύο, τον δημιουργεί καλώντας την insertVertex(id). 
        \item Μία συνάρτηση, removeEdge(v1,v2), που διαγράφει μια συγκεκριμένη ακμή.
        \item Συναρτήσεις DFS και RDFS, που υλοποιούν τους αντίστοιχους αλγορίθμους.
        \item Συνάρτηση Dijkstra(id,id), που υλοποιεί τον αλγόριθμο του Dijkstra.
        \item Συνάρτηση pickNode(), βοηθητική για την Dijkstra().
        \item Συνάρτηση, connectedComponents(), που βρίσκει τα συνεκτικά κομμάτια του γραφήματος.
        \item Συνάρτηση MST(), για την εύρεση του κόστους του ελάχιστου εκτεινόμενου δέντρου. 
        \item Συνάρτηση, increaseSIze(), που αυξάνει το μέγεθος του πίνακα κατά 10 θέσεις. 
    \end{itemize}
    \part*{Η συνάρτηση main}
    Η συνάρτηση main διαβάζει τις εντολές του αρχείου commands.txt, τις εκτελεί και γράφει το αποτέλεσμα στο αρχείο output.txt. Για κάθε γραμμή του αρχείου, 
    εξετάζει το περιεχόμενό της και αντιστοιχίζει στη δομή που αναφέρεται έναν αριθμό χρησιμοποιώντας τη συνάρτηση\\ \textbf{structuretonumber}. Έπειτα, καλεί τις 
    αντίστοιχες μεθόδους. Αξίζει να αναφερθούμε στον τρόπο με τον οποίο αντιμετωπίζεται η ενολή BUILD: Για όλες τις δομές εκτός του γραφήματος, εκμεταλευόμαστε 
    το γεγονός ότι υπάγονται στην abstract κλάση DataStructure η οποία υποστηρίζει τη μέθοδο insert. Έτσι, έχουμε την συνάρτηση \textbf{buildFromFile} η οποία 
    δέχεται ως ορίσματα το αρχείο που περιέχει τις τιμές και ένα γενικό αντικείμενο τύπου DataStructure. Το γράφημα χρειάζεται ειδική μεταχείριση καθώς το insert 
    μπορεί να αναφέρεται είτε σε κορυφή, είτε σε ακμή και η διάταξη του input file είναι διαφορετική. Για αυτόν το λόγο έχουμε κάνει overload τη συνάρτηση 
    \textbf{buildFromFile} ώστε εάν δέχεται ως δεύτερο όρισμα Graph, να λειτουργεί διαφορετικά. Για τη χρονομέτρηση χρησιμοποιείται η βιβλιοθήκη chrono της 
    C++.
    \section*{Πως συνεργαστήκαμε}
    Αρχικά, ο καθένας μας ανέλαβε να υλοποιήσει συγκεκριμένες δομές και τη συνάρτηση main. Δημιουργήσαμε ένα repository στο GitHub όπου ο καθένας μας τοποθέτησε 
    τον κώδικά του, επιτρέποντας στον άλλον να τον ελέγξει και να τον δοκιμάσει. Για το χτίσιμο της εργασίας χρησιμοποιείται το εργαλείο CMake.
\end{document}