%!TEX program = xelatex
\documentclass[12pt,a4paper]{report}
\usepackage{polyglossia}
\setmainlanguage[variant=mono]{greek}
\setotherlanguage{english}
\setmainfont[Mapping=tex-text]{GFS Elpis}
\usepackage{graphicx}

\usepackage{listings}
\lstset
{ %Formatting for code in appendix
    basicstyle=\footnotesize,
    numbers=left,
    stepnumber=1,
    showstringspaces=false,
    tabsize=1,
    breaklines=true,
    breakatwhitespace=false,
}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{qtree}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows,tikzmark}
\author{Γραμμένος Θεόδωρος} 
\title{Απαλλακτική Εργασία στη Σχεδίαση Γλωσσών Προγραμματισμού}
\date{Α.Ε.Μ.: 3294}
\begin{document}
\maketitle
\tableofcontents
\chapter{Εισαγωγή}
Στο έγγραφο αυτό περιγράφεται η δική μου υλοποίηση της απαλλακτικής εργασίας
στο μάθημα της σχεδίασης γλωσσών προγραμματισμού. Ειδικότερα, θα αναλυθεί 
ο τρόπος λειτουργίας του μεταγλωττιστή και θα περιγραφούν τα σημεία τα οποία 
είναι απαραίτητο. Παραδείγματα προγραμμάτων στη γλώσσα της εργασίας περιλαμβάνονται 
στο φάκελο Examples.
\section{Τεχνικές Λεπτομέρειες}
Ο μεταγλωττιστής υλοποιήθηκε στη γλώσσα Kotlin. Για τη διαδικασία της λεκτικής  
και της συντακτικής ανάλυσης χρησιμοποιήθηκε το εργαλείο ANTLR, το οποίο 
δημιουργεί καθοδικούς αναλυτές. Ο μεταγλωττιστής παράγει ένα αρχείο το οποίο 
περιέχει τον κώδικα σε MIXAL για το συγκεκριμένο πρόγραμμα. Έπειτα το αρχείο 
αυτό μπορεί να γίνει compile και να εκτελεστεί από έναν εξομοιωτή της 
μηχανής MIX. Κατά τις δοκιμές χρησιμοποιήθηκε ο εξομοιωτής MIX Builder. Τα αρχεία του 
λεκτικού και συντακτικού αναλυτή βρίσκονται στον φάκελο src/main/antlr.
\chapter{Τρόπος Λειτουργίας}
\section{Γενικές πληροφορίες}
Η βασική κλάση του μεταγλωττιστή είναι η ProjectListener. Η συγκεκριμένη 
κλάση υλοποιεί το interface ProjectParserBaseListener το οποίο δημιουργεί 
αυτόματα το ANTLR. Το inteface περιέχει μεθόδους enter και exit για κάθε 
σύμβολο της γραμματικής. Οι μέθοδοι αυτοί καλούνται από τον parser καθώς 
δημιουργείται το συντακτικό δέντρο του αρχείου εισόδου. Η μέθοδος enter 
ενός συμβόλου καλείται όταν το σύμβολο αναγνωρίζεται αρχικά, και δεν έχουν 
αναγνωριστεί τα παιδιά του. Κάτι τέτοιο είναι χρήσιμο όταν π.χ. 
δημιουργείται ένα καινούριο block και χρειάζεται να δημιουργηθεί πίνακας 
συμβόλων για το block. Αντίστοιχα, η μέθοδος exit καλείται όταν έχει 
ολοκληρωθεί η επεξεργασία του υποδένδρου με ρίζα αυτό το σύμβολο. 
\par
Το κάθε σύμβολο της γραμματικής περιέχει ένα πεδίο info τύπου ExprInfo 
το συγκεκριμένο πεδίο περιλαμβάνει πληροφορίες για το κάθε σύμβολο, όπως 
τη θέση του στη μνήμη, την τιμή του και τις οδηγίες που χρειάζονται για να 
υπολογιστεί. Για παράδειγμα, το πεδίο info μιας μεταβλητής περιέχει την θέση 
της μεταβλητής στην μνήμη και τον τύπο της, ενώ μιας αριθμητικής πράξης περιέχει 
τις οδηγίες που χρειάζεται για να υπολογιστεί και τη θέση στη μνήμη που αποθηκεύει 
το αποτέλεσμά της.
\par
Ο μεταγλωτιστής αξιοποιεί κυρίως τις μεθόδους exit. Οι μέθοδοι enter χρησιμοποιούνται 
για την αλλαγή της κατάστασης του μεταγλωττιστή. Καθώς ολοκληρώνεται η επεξεργασία 
των συμβόλων καλούνται διαδοχικά οι μέθοδοι exit για τα σύμβολα από κάτω προς τα 
πάνω. Ταυτόχρονα προστίθονται οι απαραίτητες πληροφορίες στο πεδίο info, καθώς 
και οι απαραίτητες οδηγίες Assembly. Παρακάτω φαίνεται το συντακτικό δέντρο μιας 
έκφρασης στη γλώσσα.
\begin{figure}[h]
\Tree [.rval(1) [.rval(2) [.rval [.term [.factor 1 ] ] ] + [.term [.factor [.ID a ] ] ] ] - 
    [.term [.term [.factor [.ID b ] ] ] * [.factor [.ID c ] ] ] ]
\caption{Συντακτικό δέντρο της έκφρασης 1+a-b*c}
\end{figure}
\par
Στο παραπάνω παράδειγμα: Αρχικά προστίθονται πληροφορίες σχετικά με τους τελεστέους. 
Για το 1 αποθηκεύεται ότι είναι literal αριθμός και η τιμή του, ενώ για το a και 
το b ελέγχεται εάν έχουν δηλωθεί, αποθηκεύεται ο τύπος τους και η θέση τους στη 
μνήμη. Στη συνέχεια, καθώς "ανεβαίνουμε" στο δέντρο στο rval(2) ελέγχεται ο τύπος 
των μεταβλητών και τοποθετούνται οι οδηγίες για τον υπολογισμό της έκφρασης στο 
πεδίο info. Επίσης στο πεδίο info αποθηκεύεται ότι π.χ. ότι το αποτέλεσμα βρίσκεται 
στον καταχωρητή A και είναι τύπου float. Ομοίως υπολογίζονται οι οδηγίες για την 
έκφραση b*c. Στο rval(1) τα πράγματα είναι πιο σύνθετα καθώς χρειάζεται πρώτα να 
υπολογιστούν οι εκφράσεις από κάτω. Λόγω της προτεραιότητας των πράξεων, τοποθετούνται 
πρώτα οι απαραίτητες οδηγίες για τον υπολογισμό του b*c. Στη συνέχεια το αποτέλεσμα 
αποθηκεύεται στη στοίβα προκειμένου να υπολογιστεί η έκφραση 1+a. Τέλος, ανακαλείται 
το αποτέλεσμα από τη στοίβα και υπολογίζεται η τελική τιμή της έκφρασης.
\par
Το συγκεκριμένο παράδειγμα είναι αρκετά απλό. Στην πραγματικότητα ενδεχομένως να 
χρειάζονται μετατροπές μεταβλητών και σταθερών από int σε float, κάτι που 
περιπλέκει το πρόγραμμα.
\section{Δομές επιλογής και επανάληψης}
Η υλοποίηση των δομών επιλογής και επανάληψης είναι πιο σύνθετη καθώς εμπλέκονται 
μεταπηδήσεις από το ένα σημείο του κώδικα σε άλλο.
\subsubsection{Δομή επανάληψης}
Η γλώσσα υποστηρίζει τις εντολές while και for. Θα αναλυθεί η δομή της while καθώς 
μια for μπορεί πολύ εύκολα να μετατραπεί σε while. 
\par
Η γενική μορφή ενός while loop σε κώδικα Assembly είναι:
\begin{figure}[h]
    \begin{flushleft}

    $\left.\begin{tabular}{l}
        LDA \dotfill\\
        ADD \dotfill\\
        \dotfill\\
        \dotfill\\
        CMPA ...
    \end{tabular}\right\} \text{Υπολογισμός της συνθήκης}$\\
    $\begin{tabular}{l}
        Jxx *+. . .
    \end{tabular}\text{Έλεγχος της συνθήκης}$\\
    $\left.\begin{tabular}{l}
        LDA . . .\\
        \dotfill\\
        \dotfill\\
    \end{tabular}\right\} \text{Εντολές μέσα στην επανάληψη}$\\
    $\begin{tabular}{l}
        JMP *-. . .
    \end{tabular}\text{Επιστροφή στην αρχή}$
    \end{flushleft}
    \caption{Γενική μορφή επανάληψης}
\end{figure}
\par
Όπως φαίνεται παραπάνω πρέπει πρώτα να είναι γνωστός ο αριθμός των 
εντολών για το κάθε μέρος έτσι ώστε να υπολογιστούν τα ακριβή νούμερα 
για τις εντολές JUMP. Συνεπώς, όταν γίνεται είσοδος σε ένα loop μέσω 
της αντίστοιχης συνάρτησης enter σταματάει το output στο αρχείο, 
υπολογίζονται οι εντολές που χρειάζεται και αντί να γίνεται output σε 
αρχείο τοποθετούνται στο πεδίο info. Φτάνοντας στο σύμβολο του loop 
με τη μέθοδο exit, έχουν υπολογιστεί οι εντολές για όλα τα παιδιά και 
συνεπώς μπορούν να υπολογιστούν οι τιμές των JUMP και να δομηθεί το 
loop.
\par 
Σε περίπτωση που το loop δεν είναι εμφολευμένο οι εντολές γράφονται 
στο αρχείο, ενώ αν είναι τοποθετούνται στο πεδίο info για να 
χρησιμοποιηθούν από το εξωτερικό loop.
\subsubsection{Δομή επιλογής}
Στη δομή επιλογής συναντώνται παρόμοιες δυσκολίες με την εντολή 
JUMP και αντιμετωπίζονται όπως και στη δομή επανάληψης.
\par
Η δομή επιλογής αποτελείται από το if-part και, προαιρετικά, από το 
else-part. Οπότε, απαιτείται τουλάχιστον μία εντολή JUMP. 
\begin{itemize}
    \item Όταν δεν υπάρχει else-part η εντολή απλώς παραλείπει το if.
    \item Όταν υπάρχει else-part το πρώτο jump μεταβαίνει στο else-part
            και τοποθετείται ένα επιπλέον JUMP στο τέλος του if-part το 
            οποίο παραλείπει το else-part.
\end{itemize}
\section{Εκτύπωση αριθμών float}
Η γλώσσα του υπολογιστή δεν παρέχει κάποια έτοιμη εντολή για την εκτύπωση 
αριθμών τύπου float. Παρέχεται η εντολή FIX η οποία μετατρέπει έναν 
πραγματικό σε ακέραιο με στρογγυλοποίηση. Για αυτόν τον λόγο για να 
εκτυπωθεί ένας float αριθμός ακολουθούνται τα παρακάτω βήματα:
\begin{enumerate}
    \item Αν ο αριθμός είναι θετικός αφαίρεσε 0.499, αν είναι αρνητικός 
            πρόσθεσε 0.499. Ο αριθμός είναι 0.499 και όχι 0.5 για να 
            αποφευχθούν σφάλματα που οφείλονται στην ακρίβεια των float 
            αριθμών.
    \item Εκτέλεσε FIX, εκτύπωσε το ακέραιο μέρος.
    \item Αφαίρεσε το ακέραιο μέρος από τον αριθμό.
    \item Πολλαπλασσίασε με το $10.000$.
    \item Κάνε FIX.
    \item Εκτύπωσε τον αριθμό που προκύπτει, δηλαδή το δεκαδικό μέρος.
\end{enumerate}
Ως αποτέλεσμα η εκτύπωσει ενός float αριθμού απαιτεί περισσότερες εντολές 
σε σχέση με την εκτύπωση ενός integer.
\chapter{Περιγραφή των κλάσεων}
\section*{exprInfo}
Περιέχει πληροφορίες για ένα σύμβολο της γραμματικής της γλώσσας. Το πεδίο 
location μπορεί να περιέχει 3 ειδικές τιμές:
\begin{itemize}
    \item LOCATION\_A όταν το αποτέλεσμα της έκφρασης βρίσκεται στον καταχωρητή Α.
    \item LOCATION\_TEMP όταν το αποτέλεσμα βρίσκεται στην θέση TEMP.
    \item LITERAL\ όταν η έκφραση αποτελεί αριθμητικό literal μέσα στο αρχείο.
\end{itemize}
\section*{AssemblyWriter}
Χειρίζεται τη δόμηση του αρχείου και την εγγραφή των εντολών σε αυτό. Επίσης, 
παρέχει στατικες μεθόδους για το formatting των εντολών.
\section*{ErrorWriter}
Παρέχει μεθόδους για την προβολή σφαλμάτων και προειδοποιήσεων κατά τη 
διάρκεια της μεταγλώττισης.
\section*{InstructionList}
Λίστα με String, τα οποία είναι σωστά διαμορφωμένα ως οδηγίες της MIX. Παρέχει 
μεθόδους για την τοποθέτηση και διαμόρφωση εντολών της MIX.
\section*{SymRec}
Περιέχει πληροφορίες για ένα σύμβολο της γλώσσας.
\section*{SymTable}
Αντιπροσωπεύει τον πίνακα συμβόλων για ένα scope της γλώσσας. Περιέχει ένα 
HashTable στο οποίο αποθηκεύονται τα σύμβολα. Παρέχει μεθόδους για τοποθέτηση 
και ανάκτηση συμβόλων.
\section*{SymTableManager}
Διαχειρίζεται πολλαπλούς πίνακες συμβόλων. Περιέχει μεθόδους για την δημιουργία 
νέων πινάκων και τη διαγραφή υπάρχοντων. Οι πίνακες αποθηκεύονται σε μία στοίβα, 
με τους νεότερους να τοποθετούνται στην κορυφή.
\section*{VarType}
Enum με τους διαθέσιμους τύπους μεταβλητών
\section*{Mover}
Περιέχει μεθόδους οι οποίες δημιουργούν τις απαραίτητες εντολές για τον χειρισμό 
μεταβλητών στη μνήμη. Για παράδειγμα η μέθοδος moveToA δέχεται ένα αντικείμενο 
τύπου ExprInfo και επιστρέφει τις οδηγίες που χρειάζονται για να μεταφερθέι το 
σύμβολο στον καταχωρητή Α.
\section*{Translator}
Χειρίζεται την μετατροπή των boolean operators σε κατάλληλες εντολές JUMP.
\chapter{Παραδείγματα}
Σε αυτήν την ενότητα θα εξεταστεί η μεταγλώττιση των παραδειγμάτων που παρέχονται 
στην εκφώνηση της εργασίας.
\section{Fibonacci}
Το πρόγραμμα υπολογίζει τους πρώτους 10 αριθμούς της σειράς Fibonacci. Για λόγους 
πληρότητας παρατίθεται ο κώδικας.
\begin{lstlisting}
mainclass Fibonacci {
public static void main ( ){
    int first, second, i, tmp;
    first=0;
    second=1;
    i=0;
    while (i<10){
        i=i+1;
        tmp=first+second;
        println (tmp);
        first=second;
        second=tmp;
        }
    }
}
\end{lstlisting}
Παρακάτω βρίσκεται ο κώδικας που παράγεται από τον μεταγλωττιστή.
\begin{lstlisting}
           ORIG 1 
TERM       EQU 18 
           ORIG 5    
TEMP       CON 0 
TEMPF      CON 0 
TOP        CON 0 
STACK      ORIG *+50 
LINE       ORIG *+24 
BEGIN      NOP 
           ENTA 0 
           STA 1 
           STA 2 
           STA 3 
           STA 4 
           ENTA 0 
           STA 1 
           ENTA 1 
           STA 2 
           ENTA 0 
           STA 3 
           LDA 3 
           ENTX 10 
           STX TEMP 
           CMPA TEMP 
           JGE *+27 
           LDA 3 
           ENTX 1 
           STX TEMP 
           ADD TEMP 
           JOV OVERFLOWEX 
           STA 3 
           LDA 1 
           ADD 2 
           JOV OVERFLOWEX 
           STA 4 
           LDA 4 
           JANN *+3 
           ENT1 45 
           ST1 LINE 
           CHAR 
           STA LINE+1 
           STX LINE+2 
           OUT LINE(TERM) 
           JBUS *(TERM) 
           ENT1 0 
           ST1 LINE 
           LDA 2 
           STA 1 
           LDA 4 
           STA 2 
           JMP *-30 
           HLT 
OVERFLOWST ALF OVERF 
           ALF LOW   
           ORIG *+22 
OVERFLOWEX OUT OVERFLOWST(TERM) 
           JBUS *(TERM) 
           HLT 
           END BEGIN 
\end{lstlisting}
\par Οι γραμμές 1-9 και 53-59 είναι σχεδόν ίδιες για όλα 
τα προγράμματα. Η μόνη διαφορά βρίσκεται στην εντολή ORIG 
στη γραμμή (3), η οποία διαφοροποιείται ανάλογα με τον 
αριθμό των μεταβλητών που περιέχει το πρόγραμμα. Οι 
γραμμές 53-59 περιέχουν οδηγίες για να εμφανιστεί μήνυμα 
όταν προκύπτει κάποια εξαίρεση. \par
Η δήλωση των μεταβλητών γίνεται στις γραμμές 10-14 του 
παραγόμενου κώδικα. Εισάγεται 0 στον καταχωρητή Α και 
και αποθηκεύεται στη θέση μνήμης κάθε μεταβλητής. Οι αναθέσεις
στις γραμμές 4-6 του αρχικού κώδικα πραγματοποιούνται στις 
γραμμές 15-20 του κώδικα MIX. Στις γραμμές 21-25 γίνεται 
ο έλεγχος της συνθήκης της επανάληψης. Στον καταχωρητή Α φορτώνεται η 
μεταβλητή i, στη θέση TEMP το 10 και γίνεται η σύγκριση. Σε περίπτωση 
που δεν ισχύει η συνθήκη γίνεται JUMP 27 γραμμές μπροστά, δηλαδή στη 
γραμμή 52. Όταν ικανοποιείται η συνθήκη της επανάληψης, η εκτέλεση 
συνεχίζεται κανονικά. Στις γραμμές 26-50 εκτελούνται οι εντολές μέσα 
στην επανάληψη. Στη γραμμή 51 υπάρχει μια εντολή JUMP προς τη γραμμή 21, 
στον έλεγχο της συνθήκης της επανάληψης.
\par
Παρακάτω φαίνεται ένα screenshot από την εκτέλεση του προγράμματος στο 
MIXBuilder.
\begin{figure}[h]
    \includegraphics[width=\linewidth]{ex1.png}
    \caption{Τα αποτελέσματα εκτέλεσης του 1ου παραδείγματος.}
\end{figure}
\\
Επίσης, στον ακόλουθο πίνακα φαίνεται η αντιστοιχία των γραμμών του αρχικού 
κώδικα με τον παραγόμενο.
\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|}
    \hline
    Αρχικός Κώδικας & Κώδικας MIX \\ \hline
    3               & 10-14       \\ \hline
    4               & 15-16       \\ \hline
    5               & 17-18       \\ \hline
    6               & 19-20       \\ \hline
    7               & 21-25,51    \\ \hline
    8               & 26-31       \\ \hline
    9               & 32-35       \\ \hline
    10              & 36-46       \\ \hline
    11              & 47-48       \\ \hline
    12              & 49-50       \\ \hline
    \end{tabular}
    \caption{Αντιστοιχία γραμμών}
    \label{tab:my-table}
    \end{table}
\section{Μέσος όρος}
Παρακάτω δίνονται ο αρχικός και ο παραγόμενος κώδικας για το δεύτερο παράδειγμα.
\begin{lstlisting}
    mainclass Example {
public static void main ( ){
    int c;
    float x, sum, mo;
    c=0;
    x=3.5;
    sum=0.0;
    while (c<5){
        sum=sum+x;
        c=c+1;
        x=x+1.5;
    }
    mo=sum/5;
    println (mo);
    }
}
\end{lstlisting}
\begin{lstlisting}
           ORIG 1 
TERM       EQU 18 
           ORIG 5    
TEMP       CON 0 
TEMPF      CON 0 
TOP        CON 0 
STACK      ORIG *+50 
LINE       ORIG *+24 
BEGIN      NOP 
           ENTA 0 
           STA 1 
           ENTA 0 
           STA 2 
           STA 3 
           STA 4 
           ENTA 0 
           STA 1 
           ENTA 35 
           ENTX 10 
           STX TEMPF 
           FDIV TEMPF 
           STA 2 
           ENTA 00 
           ENTX 10 
           STX TEMPF 
           FDIV TEMPF 
           STA 3 
           LDA 1 
           ENTX 5 
           STX TEMP 
           CMPA TEMP 
           JGE *+29 
           LDA 3 
           FADD 2 
           JOV OVERFLOWEX 
           STA 3 
           LDA 1 
           ENTX 1 
           STX TEMP 
           ADD TEMP 
           JOV OVERFLOWEX 
           STA 1 
           LDA 2 
           LD5 TOP 
           STA STACK,5 
           INC5 1 
           ST5 TOP 
           ENTA 15 
           ENTX 10 
           STX TEMPF 
           FDIV TEMPF 
           STA TEMP 
           LD5 TOP 
           DEC5 1 
           LDA STACK,5 
           ST5 TOP 
           FADD TEMP 
           JOV OVERFLOWEX 
           STA 2 
           JMP *-32 
           LDA 3 
           LD5 TOP 
           STA STACK,5 
           INC5 1 
           ST5 TOP 
           ENTX 5 
           STX TEMP 
           LDA TEMP 
           FLOT 
           STA TEMP 
           LD5 TOP 
           DEC5 1 
           LDA STACK,5 
           ST5 TOP 
           FDIV TEMP 
           JOV OVERFLOWEX 
           STA 4 
           LDA 4 
           STA TEMP 
           ENTA 1000 
           STA TEMPF 
           ENTA 499 
           FDIV TEMPF 
           STA TEMPF 
           LDA TEMP 
           JAN *+3 
           FSUB TEMPF 
           JMP *+2
           ENT1 45 
           ST1 LINE 
           STA TEMPF 
           CHAR 
           STX LINE+1 
           LDA TEMPF 
           FLOT 
           STA TEMPF 
           ENTA 40 
           SLA 4 
           STA LINE+2 
           LDA TEMP 
           FSUB TEMPF 
           STA TEMPF 
           ENTA 100 
           STA TEMP 
           MUL TEMP 
           SLAX 5 
           FLOT 
           FMUL TEMPF 
           FIX 
           CHAR 
           STX LINE+4(2:5) 
           OUT LINE(TERM) 
           JBUS *(TERM) 
           ENT1 0 
           ST1 LINE 
           HLT 
OVERFLOWST ALF OVERF 
           ALF LOW   
           ORIG *+22 
OVERFLOWEX OUT OVERFLOWST(TERM) 
           JBUS *(TERM) 
           HLT 
           END BEGIN 
\end{lstlisting}
\par Ο τρόπος λειτουργίας του προγράμματος είναι αντίστοιχος 
με το προηγούμενο παράδειγμα. Η κύρια διαφορά είναι ότι σε 
αυτό το πρόγραμμα υπάρχουν και αριθμοί float, οπότε χρησιμοποιούνται 
αριθμητικές εντολές για αριθμούς float (π.χ. FADD αντι για ADD).
\\
\begin{figure}[h]
    \includegraphics[width=\linewidth]{ex2.png}
    \caption{Τα αποτελέσματα εκτέλεσης του 2ου παραδείγματος.}
\end{figure}
\end{document}